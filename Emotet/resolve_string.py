import idaapi
import idc
import idautils
import struct
def resolve_all_strings(resolve_ea, type=0):
    if resolve_ea is None:
        print('resolve fails..')
        return

    if type == 1:
        resolve_ea = 0x1001FABB
        for ref in idautils.CodeRefsTo(resolve_ea, 1):
            encoded_buffer_ea = 0
            curr_ea = ref
            while True:
                prev_instruction_ea = idc.prev_head(curr_ea)
                if 'mov' in str(idc.GetDisasm(prev_instruction_ea)) and 'ecx' in str(idc.GetDisasm(prev_instruction_ea)):
                    encoded_buffer_ea = idc.get_operand_value(prev_instruction_ea, 1)
                    break
                curr_ea = prev_instruction_ea
            if encoded_buffer_ea != 1:
                decoded_string= get_string(encoded_buffer_ea)
                idc.set_cmt(ref, decoded_string, 0)
        return
    for ref in idautils.CodeRefsTo(resolve_ea, 1):
        curr_ea = ref
        
        stop_count = 0
        encoded_buffer_ea = 0
        while stop_count < 2:
            prev_instruction_ea = idc.prev_head(curr_ea)
            if idc.print_insn_mnem(prev_instruction_ea) == 'push':
                if stop_count == 1:
                    encoded_buffer_ea = idc.get_operand_value(prev_instruction_ea, 0)
                stop_count += 1

            curr_ea = prev_instruction_ea
        if encoded_buffer_ea != 1:
            decoded_string = get_string(encoded_buffer_ea)
            print(hex(curr_ea), decoded_string)
            idc.set_cmt(ref, decoded_string, 0)

def get_string(encoded_buffer_ea):
    result = ''
    xor_key = idc.get_wide_dword(encoded_buffer_ea) 
    string_length = xor_key ^ idc.get_wide_dword(encoded_buffer_ea + 4)
    encoded_buffer_ea += 8
    xor_key = [each for each in struct.pack('i', xor_key)]
    for i in range(string_length):
        curr_char = xor_key[i % len(xor_key)] ^ idc.get_wide_byte(encoded_buffer_ea + i)
        result += chr(curr_char)
    return result

def decrypt_buffer(encoded_buffer_ea):
    result = []
    xor_key = idc.get_wide_dword(encoded_buffer_ea) 
    string_length = xor_key ^ idc.get_wide_dword(encoded_buffer_ea + 4)
    encoded_buffer_ea += 8
    xor_key = [each for each in struct.pack('i', xor_key)]
    for i in range(string_length):
        curr_char = xor_key[i % len(xor_key)] ^ idc.get_wide_byte(encoded_buffer_ea + i)
        result.append(curr_char)
    return result


def get_ip_conf(decoded_C2_buffer):
    C2_url = []

    for i in range(0, len(decoded_C2_buffer), 8):
        first = str(decoded_C2_buffer[i])
        second = str(decoded_C2_buffer[i+1])
        third = str(decoded_C2_buffer[i+2])
        fourth = str(decoded_C2_buffer[i+3])
        port = str(decoded_C2_buffer[i+5] | decoded_C2_buffer[i+4] << 8)

        print(port)
        #  v11 | (v10 << 8)
        secure_flag = str(decoded_C2_buffer[i + 7] | (decoded_C2_buffer[i+6] << 8))
        C2_url.append(first + '.' + second + '.' + third + '.' + fourth + ':' +
                port + ':' + secure_flag)


    print(C2_url)

#  resolve_all_strings(0x10017AF5)
#  resolve_all_strings(12, 1)
# exception 0x1001fb2b 

print(get_ip_conf(decrypt_buffer(0x10025000)))
print(get_string(0x100016A0))










