import idaapi
import idc
import idautils


def translate_ea(offset):
    for s in idautils.Segments():
        if idc.get_segm_name(s) == ".text":
            return offset + s

    print('translate_ea fails..')
    return None


def decrypt(start_ea, end_ea, type, a, b):
    encrypted_buffer = []

    if start_ea is None or end_ea is None:
        print('cant decrypt')
        return

    curr = start_ea

    while curr <= end_ea:
        encrypted_buffer.append(idc.get_operand_value(curr, 1))
        print(hex(idc.get_operand_value(curr, 1)))
        curr = idc.next_head(curr)

    result = ''
    # a*(b-buff[i])
    if type == 1:
        for each in encrypted_buffer:
            temp = (a * (b - each) % 127 + 127) % 127
            if temp != 0:
                result += chr(temp)
    elif type == 2:  # a * (buffer[i] - b)
        for each in encrypted_buffer:
            temp = (a * (each - b) % 127 + 127) % 127
            if temp != 0:
                result += chr(temp)

    return result


# pass the first stack string instruction in the first parameter
# the last stack string instruction in the second parameter
# there's 2 decryption mode above, pick 1
# the fourth parameter is a and the last parameter is b

print(decrypt(translate_ea(0x172b0), translate_ea(0x172ec), 2, 10, 52))
