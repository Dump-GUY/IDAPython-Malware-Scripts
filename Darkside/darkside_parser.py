import idaapi, idc, idautils


def resolve_string(encrypted_string, length):
    v3 = int(length / 0xFF)
    v4 = length % 0xFF
    if v3 != 0:
        v5 = int(length / 0xFF)

        while v5 != 0:
            encrypted_string = decrypt_string(encrypted_string, 255)
            v5 -= 1
    if v4 != 0:
        encrypted_string = decrypt_string(encrypted_string, v4)

    return ''.join([chr(x) for x in encrypted_string])[:-1] # eliminate null pointer cause it's not a thing in Python

def decrypt_string(encrypted_string, length):
    BUFFER_OFFSET_COUNTER = 0
    BUFFER1_COUNTER = 0
    BUFFER1 = []
    for i in KEY_BUFFER:
        BUFFER1.append(i)

    v2 = 0
    v4 = 0
    curr_index = 0
    v6 = 0

    while length != 0:
        v4 = (BUFFER1[1 + v2] + v4) & 0xFF
        v6 = BUFFER1[1 + v2] & 0xFF
        v7 = BUFFER1[v4] & 0xFF
        BUFFER1[v4] = v6
        BUFFER1[1 + v2] = v7
        v6 = (v7 + v6) & 0xFF
        v2 += 1
        encrypted_string[curr_index] ^= BUFFER1[v6]
        curr_index += 1
        length -= 1
    return encrypted_string

def init_resolve_buffer(key1, key2, length):
    global KEY_BUFFER
    v3 = 240
    v4 = key1[0]
    v5 = key1[1]
    v6 = key1[2]
    v7 = key1[3]

    def _copy_bytes(integer, BUFFER, offset):
        for i in range(0, 4):
            BUFFER[offset + i] = integer & 0xff
            integer >>= 8
        return BUFFER

    while v3 >= 0:
        KEY_BUFFER = _copy_bytes(v4, KEY_BUFFER, v3 + 12)
        KEY_BUFFER = _copy_bytes(v7, KEY_BUFFER, v3 + 8)
        KEY_BUFFER = _copy_bytes(v5, KEY_BUFFER, v3 + 4)
        KEY_BUFFER = _copy_bytes(v6, KEY_BUFFER, v3)
        v4 -= 0x10101010
        v7 -= 0x10101010
        v5 -= 0x10101010
        v6 -= 0x10101010
        v3 -= 16

    lo_v8 = 0
    v9 = 0
    v10 = 0

    while True:
        while True:
            lo_result = KEY_BUFFER[v9] & 0xff
            lo_v8 = (lo_result + ((key2[v10] + lo_v8) & 0xff)) & 0xff
            hi_result = KEY_BUFFER[lo_v8]

            v10 += 1
            KEY_BUFFER[lo_v8] = lo_result
            KEY_BUFFER[v9] = hi_result
            if v10 >= length:
                break
            v9 += 1
            v9 &= 0xff
            if v9 == 0:
                return

        v10 = 0
        v9 += 1
        v9 &= 0xff
        if v9 == 0:
            break


def get_encrypted_lib_table():
    LoadLibraryA_ea = idc.get_name_ea_simple("LoadLibraryA")
    LoadLibraryA_ref = None
    if LoadLibraryA_ea != idaapi.BADADDR:    
        for ref in idautils.CodeRefsTo(LoadLibraryA_ea, 1):
            LoadLibraryA_ref = ref 
            break
    ENCRYPTED_LIB_TABLE_instruction_ea = LoadLibraryA_ref - 22
    API_TABLE_start_instruction_ea = LoadLibraryA_ref - 16

    if 'lea' not in idc.GetDisasm(ENCRYPTED_LIB_TABLE_instruction_ea) or 'lea' not in idc.GetDisasm(API_TABLE_start_instruction_ea):
        print(hex(ENCRYPTED_LIB_TABLE_instruction_ea))
        print('Parsing fails...')
        return



    ENCRYPTED_LIB_TABLE_ea = idc.get_operand_value(ENCRYPTED_LIB_TABLE_instruction_ea, 1)
    ENCRYPTED_LIB_TABLE_ea -= 4
    
    global API_TABLE_start_ea
    API_TABLE_start_ea = idc.get_operand_value(API_TABLE_start_instruction_ea, 1)

    global ENCRYPTED_LIB_TABLE
    # 3694 bytes
    ENCRYPTED_LIB_TABLE = idaapi.get_bytes(ENCRYPTED_LIB_TABLE_ea, 3694)

def get_KEY_BUFFER(init_resolve_func_ea):
    global KEY_BUFFER


    if init_resolve_func_ea is None:
        print('get_KEY_BUFFER fails...')
        return None

    print(hex(init_resolve_func_ea))
    ref_ea = None
    for ref in idautils.CodeRefsTo(init_resolve_func_ea, 1):
        # only 1 ref
        ref_ea = ref
        break
    
    arg_list = [0, 0, 0]

    curr_ea = ref_ea
    for i in range(0, 3):
        while True:
            prev_instruction_ea = idc.prev_head(curr_ea)
            if idc.print_insn_mnem(prev_instruction_ea) == 'push':
                arg_list[i] = idc.get_operand_value(prev_instruction_ea, 0)
                curr_ea = prev_instruction_ea
                break
            
                
    
    key1 = []
    key1_ea = arg_list[0]
    length = arg_list[2]

    while key1_ea < arg_list[0] + length:
        key1.append(int.from_bytes(idaapi.get_bytes(key1_ea, 4), 'little'))

        key1_ea += 4

    key2 = []
    key2_ea = arg_list[1]

    while key2_ea < arg_list[1] + length:
        key2.append(int.from_bytes(idaapi.get_bytes(key2_ea, 1), 'little'))
        key2_ea += 1

    init_resolve_buffer(key1, key2, length)


def translate_ea(offset):
    for s in idautils.Segments():
        if idc.get_segm_name(s) == ".text":
            return offset + s

    print('translate_ea fails..')
    return None


ENCRYPTED_LIB_TABLE = None
API_TABLE_start_ea = 0

BUFFER1 = []
KEY_BUFFER = []
BUFFER1_COUNTER = 0
BUFFER_OFFSET_COUNTER = 0
ENCRYPTED_LIB_TABLE_counter = 0

Darkside_DLL_LIST = set(['ntdll', 'kernel32', 'advapi32', 'shell32', 'ole32', 'oleaut32', 'mpr',
                         'iphlpapi', 'shlwapi', 'gdi32', 'user32', 'netapi32', 'wsock32', 'wininet', 'wtsapi32'])

def main():
    global ENCRYPTED_LIB_TABLE_counter, BUFFER1, KEY_BUFFER, Darkside_DLL_LIST, API_TABLE_start_ea

    for i in range(0, 256):
        BUFFER1.append(0)
        KEY_BUFFER.append(0)
    get_KEY_BUFFER(translate_ea(0x71C))
    get_encrypted_lib_table()

    length = int.from_bytes(ENCRYPTED_LIB_TABLE[ENCRYPTED_LIB_TABLE_counter:ENCRYPTED_LIB_TABLE_counter + 4], 'little')
    ENCRYPTED_LIB_TABLE_counter += 4
    counter = 0

    curr_API_ea = API_TABLE_start_ea

    while length!= 0:
        encrypted_string = [x for x in ENCRYPTED_LIB_TABLE[ENCRYPTED_LIB_TABLE_counter:ENCRYPTED_LIB_TABLE_counter+length]]
        resolved_API = resolve_string(encrypted_string, length)
        print(resolved_API)
        if resolved_API not in Darkside_DLL_LIST:
            idc.set_name(curr_API_ea, 'mw_' + resolved_API) 
            curr_API_ea += 4
        ENCRYPTED_LIB_TABLE_counter += length
        length = int.from_bytes(ENCRYPTED_LIB_TABLE[ENCRYPTED_LIB_TABLE_counter:ENCRYPTED_LIB_TABLE_counter + 4], 'little')
        ENCRYPTED_LIB_TABLE_counter += 4


if __name__ == "__main__":
    main()
